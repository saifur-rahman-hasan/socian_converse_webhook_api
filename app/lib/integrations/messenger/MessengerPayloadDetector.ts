import {getAutoGeneratedSourceMid} from "@/utils/helperFunctions";

export default class MessengerPayloadDetector {
    private payload: MessengerMessagePayloadInterface;
    private senderId: string;
    private recipientId: string;
    private channelAccountId: string;

    constructor(payload: MessengerMessagePayloadInterface, channelAccountId: string) {
        this.payload = payload;
        this.senderId = payload.sender.id
        this.recipientId = payload.recipient.id
        this.channelAccountId = channelAccountId
    }

    detectPayloadType(): string {
        const {
            message,
            delivery,
            postback,
            reaction,
            read
        } = this.payload;

        if (message && this.isConsumerMessage() && message.is_echo) {
            return 'echo';
        } else if (!message && this.isConsumerMessage() && delivery) {
            return 'message_deliveries';
        } else if (postback) {
            return 'postback';
        } else if (reaction) {
            return 'message_reactions';
        } else if (!message && this.isConsumerMessage() && read) {
            return 'message_reads';
        } else if (message && message.quick_reply && message.quick_reply.payload) {
            return 'quick_reply';
        } else if (message && message.reply_to && message.reply_to.mid) {
            return 'reply';
        } else if (message && message.attachments && message.attachments.length > 0) {
            const attachmentType = message.attachments[0].type;
            return `attachment_${attachmentType}`;
        } else if (message && message.referral && message.referral.product && message.referral.product.id) {
            return 'product_referral';
        } else if(this.isConsumerMessage() && message.text?.length > 0 && !message.attachments?.length){
            return 'text';
        } else if(message.text?.length > 0 && !message.attachments?.length){
            return 'text';
        } else {
            return 'other';
        }
    }

    isConsumerMessage(): boolean {
        return this.senderId !== this.channelAccountId;
    }

    isChannelMessage() {
        return this.senderId === this.channelAccountId
    }

    getSourceMidFromMessageType(): string | undefined {
        const {
            message,
            postback,
            reaction,
            read,
            delivery
        } = this.payload;

        if (message && message.mid) {
            return message.mid;
        } else if (postback && postback.mid) {
            return postback.mid;
        } else if (reaction && reaction.mid) {
            return reaction.mid;
        } else if (read && read.watermark) {
            // Assuming read is associated with a specific message.
            // If not, you can modify this condition accordingly.
            return read.watermark.toString();
        } else if(delivery){
            return delivery.mids[0].toString();
        } else {
            return getAutoGeneratedSourceMid("undefined_source_mid__");
        }
    }
}

export interface MessengerMessagePayloadInterface {
    sender: {
        id: string;
    };
    recipient: {
        id: string;
    };
    timestamp: number;
    message: {
        mid: string;
        text?: string;
        quick_reply?: {
            payload: string;
        };
        reply_to?: {
            mid: string;
        };
        attachments?: Array<{
            type: string;
            payload: {
                url: string;
                title?: string;
                sticker_id?: number;
            };
        }>;
        referral?: {
            product: {
                id: string;
            };
        };
        is_echo?: boolean; // Add the is_echo property here
        app_id?: number;
        metadata?: string;
    };
    delivery?: {
        mids: string[];
        watermark: number;
    };
    postback?: {
        mid: string;
        title: string;
        payload: string;
        referral?: {
            ref: string;
            source: string;
            type: string;
        };
    };
    reaction?: {
        reaction: string;
        emoji: string;
        action: string;
        mid: string;
    };
    read?: {
        watermark: number;
    };

    lastmessages?: any | null
}