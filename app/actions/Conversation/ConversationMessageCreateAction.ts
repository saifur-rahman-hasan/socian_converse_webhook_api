import BaseAction from "@/actions/BaseAction";
import {ChannelDataRequiredInterface} from "@/actions/interface/ChannelInterface";
import {
    ConversationDocOutputInterface,
    ConversationLastMessageInterface,
    ConversationMessageCreateInputInterface,
    ConversationMessageDocOutputInterface,
    ConversationMessageUpdateInputInterface
} from "@/actions/interface/ConversationInterface";
import {getAutoGeneratedSourceMid} from "@/components/Converse/ConverseMessengerApp/MessengerReplayForm";
import ConverseMessengerSocketEmitter from "@/lib/ConverseMessengerService/ConverseMessengerSocketEmitter";
import {throwIf} from "@/lib/ErrorHandler";
import ConversationQuery from "@/lib/QueryServices/elasticsearch/ConversationQuery";
import MessageQuery from "@/lib/QueryServices/elasticsearch/MessageQuery";
import FacebookPostCommentService, {
    FacebookPagePostCommentReplayInterface
} from "@/lib/integrations/facebookPage/FacebookPostCommentService";
import AirtelMessageSenderService from "@/lib/integrations/other/Airtel/AirtelMessageSenderService";
import RobiMessageSenderService from "@/lib/integrations/other/Robi/RobiMessageSenderService";
import MessengerService from "@/lib/messenger/MessengerService";
import {debugLog} from "@/utils/helperFunctions";

export default class ConversationMessageCreateAction extends BaseAction{
    private workspaceId: number;
    private channelId: number;
    private userId: number;
    private message: ConversationMessageCreateInputInterface;

    private messageQuery: MessageQuery
    private conversationQuery: ConversationQuery;
    private newDate: Date;
    private channel: any = null;
    private isAgentReplied: boolean = false;
    private messageSourceMid: string;
    private conversationId: string;
    private currentThreadId: number;
    private conversation: ConversationDocOutputInterface;
    private conversationMessage: ConversationMessageDocOutputInterface;

    constructor(
        workspaceId: number,
        channelId: number,
        userId: number,
        conversationId: string,
        currentThreadId: number,
        sourceMid: string,
        channel: any,
        message: ConversationMessageCreateInputInterface,
    ) {
        super()
        
        this.newDate = new Date
        this.workspaceId = workspaceId;
        this.channelId = channelId;
        this.userId = userId;
        this.message = message
        this.isAgentReplied = message?.isAgentReplied || false
        this.messageQuery = new MessageQuery()
        this.conversationQuery = new ConversationQuery()


        this.conversationId = conversationId
        this.currentThreadId = currentThreadId
        this.channel = channel
        this.messageSourceMid = sourceMid ? sourceMid : this?.message?.sourceMid || getAutoGeneratedSourceMid('UNDEFINED_')
    }

    async execute(){
        try {
            const channelType = this?.channel?.channelType
            const isAgentReplied = this.message.isAgentReplied || false

            throwIf(
                !this.messageSourceMid?.length,
                new Error('Sorry! Your sourceMid is missing.')
            )

            // TODO: 1. Find the message doc is already exists using sourceMid
            const findMessage = await this.findConversationMessageExists(
                this.conversationId,
                this.messageSourceMid
            )

            throwIf(
                findMessage?._id,
                new Error('Sorry! This Conversation Message Already exists')
            )

            const conversationDoc = await (new ConversationQuery())
                .findConversationById(this.conversationId)

            // TODO: 1. Create New Message Doc
            const messageDoc: ConversationMessageDocOutputInterface = await this.createNewMessageDoc(
                this.conversationId,
                this.currentThreadId
            )

            const messageDocId = messageDoc?._id || null
            throwIf(!messageDocId, new Error('Invalid message doc id while creating'))

            // TODO: Update the last message to the conversation and update the total message count
            this.conversation = await this.updateConversationDoc(messageDoc)
            this.conversationMessage = messageDoc

            // TODO: Dispatch Socket Events
            await this.dispatchSocketEvents()

            // TODO: Send Message To The Associate Channel
            if(isAgentReplied === true){
                this.sendMessageToTheAssociateChannel()
            }

            throwIf(!this.conversation?._id || !this.conversationMessage?._id, new Error('Invalid Message Create Response'))

            return Promise.resolve({
                conversation: this.conversation,
                conversationMessage: this.conversationMessage
            })

        }catch (e) {
            debugLog(`message create action error: `, e)

            return Promise.reject(e.message)
        }
    }

    private async createNewMessageDoc(
        conversationDocId: string,
        currentThreadId: number|string
    ): Promise<ConversationMessageDocOutputInterface> {
        try {

            throwIf(!conversationDocId, new Error("ConversationDocId is missing"))
            throwIf(!currentThreadId, new Error("currentThreadId is missing"))

            this.message = {
                ...this.message,
                conversationId: conversationDocId,
                threadId: currentThreadId
            }

            const newMessage: ConversationMessageDocOutputInterface = await this
                .messageQuery
                .createAndGetMessageDoc(this.message)

            return Promise.resolve(newMessage)

        }catch (e) {
            return Promise.reject(e)
        }
    }

    private async findConversationMessageExists(conversationId, sourceMid) {
        try {
            const promiseData: ConversationMessageDocOutputInterface = await this.messageQuery
                .findUniqueConversationMessageDocBySourceMid(
                    conversationId,
                    sourceMid
                )

            return Promise.resolve(promiseData)
        }catch (e) {
            return Promise.reject(e)
        }
    }

    private async updateNewMessageDoc(messageDocId: string, data: ConversationMessageUpdateInputInterface): Promise<ConversationMessageDocOutputInterface> {
        try {
            const promiseData: ConversationMessageDocOutputInterface = await this.messageQuery.updateAndGetConversationMessageDoc(
                messageDocId,
                data
            )

            return Promise.resolve(promiseData)
        }catch (e) {
            this.setActionErrorReject(e)
            return Promise.reject(e)
        }
    }

    private dispatchSocketEvents() {
        try {

            const MessengerEvent = new ConverseMessengerSocketEmitter(
                this.workspaceId,
                this.channelId
            )

            const conversationData = this.conversation
            const messageData = this.conversationMessage

            MessengerEvent.conversationUpdated(conversationData)
            MessengerEvent.messageAdded(messageData)

            return Promise.resolve(true)
        }catch (e) {
            return Promise.resolve(false)
        }
    }

    private async updateConversationDoc(messageDoc: ConversationMessageDocOutputInterface) {
        try {

            const lastMessage: ConversationLastMessageInterface = {
                id: messageDoc._id,
                messageType: messageDoc.messageType,
                content: messageDoc.content,
                createdTime: this.message.createdTime
            }

            const messagesCount = 0

            const updatableConversationData = {
                lastMessage,
                messagesCount,
            }

            const updatedConversationDoc: ConversationDocOutputInterface = await this.conversationQuery
                .updateAndGetConversationDoc(
                    messageDoc.conversationId,
                    updatableConversationData
                )

            return Promise.resolve(updatedConversationDoc)
        }catch (e) {
            return Promise.reject(e)
        }
    }

    private async sendMessageToTheAssociateChannel() {
        try {
            const channel = this.channel
            const channelType = this.channel.channelType
            const message = this.message

            let resolvedData = null
            const recipientId = message.to.id

            switch (channelType){
                case 'messenger':
                    console.log('Sending Message From messenger channel')
                    resolvedData = await this.sendMessageToMessengerChannel(
                        channel,
                        recipientId,
                        message
                    )
                    break

                case 'fb_page':
                case 'facebook_page':
                    console.log('Sending Message From facebook_page channel')
                    resolvedData = await this.sendMessageToFacebookPageChannel(
                        channel,
                        recipientId,
                        message,
                    )
                    break
            }

            console.log(`resolvedData: `, resolvedData)

            return Promise.resolve(resolvedData)
        }catch (e) {
            console.log(`rejectData: `, e)
            return Promise.reject(e)
        }
    }

    private async sendMessageToMessengerChannel(
        channel,
        recipientId: string,
        message: ConversationMessageCreateInputInterface
    ) {
        try {
            const channelData: any = channel?.channelData
            const channelAccountId: string = channelData?.accountId || ''
            const channelAccessToken: string = channelData?.accessToken || channelData?.access_token || ''

            throwIf(
                !channelAccountId || !channelAccessToken,
                new Error("The Channel is authorized to send message to the messenger")
            )

            const isThirdPartyChannel: boolean = channelData?.isThirdParty || false
            const thirdPartyServiceName: string = channelData?.thirdPartyServiceName || null

            const pageId = channelData?.accountId
            const pageAccessToken = channelData?.accessToken || channelData?.access_token
            const iceFeedback: boolean = message.iceFeedback
            const messageContent = message.content

            const workspaceId: number = this.workspaceId
            const channelId: number = this.channelId
            const conversationDoc = this.conversation
            const messageDoc = this.conversationMessage
            const messageDocId: string = messageDoc?._id

            throwIf(
                !messageDocId,
                new Error('Message Doc Id is not valid while sending message from messenger channel')
            )

            let messageSendResponse = null
            let messageSentData = {}

            debugLog('Before -> sendMessageViaThirdPartyService', {
                isThirdPartyChannel,
                thirdPartyServiceName,
                message
            })

            if(isThirdPartyChannel && thirdPartyServiceName){
                messageSendResponse = await this.sendMessageViaThirdPartyService(
                    thirdPartyServiceName,
                    channelAccountId,
                    recipientId,
                    message
                )

                messageSentData = { messageSentStatus: messageSendResponse.success ? 'sent-success' : 'sent-failed', messageSentResponse: messageSendResponse}

                console.log(`third party service message sent response`)
                console.log(messageSendResponse)

                const updatedMessageDoc: ConversationMessageDocOutputInterface = await this.messageQuery.updateAndGetConversationMessageDoc(
                    messageDocId,
                    messageSentData
                )

                const MessengerEvent = new ConverseMessengerSocketEmitter(
                    workspaceId,
                    channelId
                )

                MessengerEvent.messageAdded(updatedMessageDoc)

                await this.dispatchSocketEvents()

            }else{
                const messengerService = new MessengerService(pageId, pageAccessToken)

                if(iceFeedback){
                    messageSendResponse = await messengerService
                        .sendIceFeedbackMessage(
                            recipientId
                        )
                }else{
                    messageSendResponse = await messengerService
                        .sendMessage(
                            recipientId,
                            messageContent
                        )
                }


                if(messageSendResponse?.message_id){
                    console.log('fb-messenger:message-sent-success')
                    console.log(messageSendResponse?.message_id)
                    messageSentData = { messageSentStatus: 'sent-success', messageSentResponse: messageSendResponse}
                }else{
                    console.log('fb-messenger:message-sent-failed')
                    messageSentData = { messageSentStatus: 'sent-fail', messageSentResponse: {}}
                }

                console.log(`messageDocId: `, messageDocId)
                const updatedMessageDoc: ConversationMessageDocOutputInterface = await this.messageQuery.updateAndGetConversationMessageDoc(
                    messageDocId,
                    messageSentData
                )
                console.log(`updatedMessageDoc: `, updatedMessageDoc)
                const MessengerEvent = new ConverseMessengerSocketEmitter(
                    workspaceId,
                    channelId
                )

                MessengerEvent.messageAdded(updatedMessageDoc)

                await this.dispatchSocketEvents()
            }

            return Promise.resolve(messageSentData)
        }catch (e) {
            return Promise.reject(e)
        }
    }

    async sendMessageViaThirdPartyService(
        thirdPartyServiceName: any,
        channelAccountId : string,
        recipientId: string,
        message: any
    ) {


        debugLog('Before -> sendMessageViaThirdPartyService', {
            channelAccountId,
            thirdPartyServiceName,
            recipientId
        })

        let serviceResponse: any = {
            success: false,
            error: 'undefined_service_response',
            data: null
        }

        throwIf(channelAccountId === recipientId, new Error("Cannot send message to same channel"))

        switch (thirdPartyServiceName) {

            case "robi_messenger":
                const robiMessageMid : string = message.sourceMid
                const robiMessageType: string = message.messageType
                const robiMessageText: string = message.content

                const robiMessageSenderService: RobiMessageSenderService = new RobiMessageSenderService()

                if(robiMessageType === 'text'){
                    serviceResponse = await robiMessageSenderService.sendTextMessage(recipientId, channelAccountId, robiMessageMid, robiMessageText)
                }else if(robiMessageType === 'iceFeedback'){
                    serviceResponse = await robiMessageSenderService.sendIceFeedbackMessage(recipientId, channelAccountId, robiMessageMid)
                }

                break


            case "airtel_messenger":
                const airtelMessageMid : string = message.sourceMid
                const airtelMessageType: string = message.messageType
                const airtelMessageText: string = message.content

                const airtelMessageSenderService: AirtelMessageSenderService = new AirtelMessageSenderService()

                if(airtelMessageType === 'text'){
                    serviceResponse = await airtelMessageSenderService.sendTextMessage(recipientId, channelAccountId, airtelMessageMid, airtelMessageText)
                }else if(airtelMessageType === 'iceFeedback'){
                    serviceResponse = await airtelMessageSenderService.sendIceFeedbackMessage(recipientId, channelAccountId, airtelMessageMid)
                }
                break

        }

        return Promise.resolve(serviceResponse)
    }

    private async sendMessageToFacebookPageChannel(
        channel,
        recipientId: string,
        message: ConversationMessageCreateInputInterface
    ) {
        try {
            const channelData: ChannelDataRequiredInterface | any = channel?.channelData
            const channelAccountId: string = channelData?.accountId || ''
            const channelAccessToken: string = channelData?.accessToken || channelData?.access_token || ''

            throwIf(
                !channelAccountId || !channelAccessToken,
                new Error("The Channel is authorized to send message to the messenger")
            )

            const isThirdPartyChannel: boolean = channelData?.isThirdParty || false
            const thirdPartyServiceName: string = channelData?.thirdPartyServiceName || null

            const iceFeedback: boolean = message.iceFeedback

            const workspaceId: number = this.workspaceId
            const channelId: number = this.channelId
            const conversationDoc = this.conversation
            const messageDoc = this.conversationMessage
            const messageDocId: string = messageDoc?._id

            throwIf(
                !messageDocId,
                new Error('Message Doc Id is not valid while sending message from messenger channel')
            )

            let messageSendResponse = null
            let messageSentData = {}

            if(isThirdPartyChannel && thirdPartyServiceName){
                // TODO: Need to implement third party
            }else{
                const commentService = new FacebookPostCommentService(channelData)

                if(iceFeedback){
                    // messageSendResponse = await commentService
                    //     .sendIceFeedbackMessage(
                    //         recipientId
                    //     )
                }else{
                    const commentReplayData: FacebookPagePostCommentReplayInterface = {
                        comment_id: message.to.id,
                        message: message.content
                    }

                    messageSendResponse = await commentService.sendMessage( commentReplayData )
                }

                console.log('messageSendResponse: ', messageSendResponse)

                if(messageSendResponse?.data?.id){
                    console.log('fb-messenger:message-sent-success')
                    messageSentData = { messageSentStatus: 'sent-success', messageSentResponse: messageSendResponse}
                }else{
                    console.log('fb-messenger:message-sent-failed')
                    messageSentData = { messageSentStatus: 'sent-fail', messageSentResponse: {}}
                }

                const updatedMessageDoc: ConversationMessageDocOutputInterface = await this.messageQuery.updateAndGetConversationMessageDoc(
                    messageDocId,
                    messageSentData
                )

                const MessengerEvent = new ConverseMessengerSocketEmitter(
                    workspaceId,
                    channelId
                )

                MessengerEvent.messageAdded(updatedMessageDoc)

                await this.dispatchSocketEvents()
            }

            return Promise.resolve(messageSentData)
        }catch (e) {
            return Promise.reject(e)
        }
    }
}

function generateUniqueId() {
    const timestamp = Date.now();
    return parseInt(String(timestamp), 10);
}
