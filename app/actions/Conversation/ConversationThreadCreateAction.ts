import BaseAction from "@/actions/BaseAction";
import {
	AssignableTaskDocOutputInterface,
	ConversationDocOutputInterface, ConversationLastMessageInterface,
	ConversationMessageCreateInputInterface,
	ConversationMessageDocOutputInterface,
	ConversationParticipantUserInterface,
	ConversationThreadOutputInterface,
	ThreadCreateInputInterface
} from "@/actions/interface/ConversationInterface";
import {debugLog, getChannelAutoReplayContent} from "@/utils/helperFunctions";
import ConversationQuery from "@/lib/QueryServices/elasticsearch/ConversationQuery";
import ChannelQuery from "@/lib/QueryServices/backend/ChannelQuery";
import {throwIf} from "@/lib/ErrorHandler";
import collect from "collect.js";
import ThreadQuery from "@/lib/QueryServices/backend/ThreadQuery";
import MessageQuery from "@/lib/QueryServices/elasticsearch/MessageQuery";
import ConversationMessageCreateAction from "@/actions/Conversation/ConversationMessageCreateAction";
import {getAutoGeneratedSourceMid} from "@/components/Converse/ConverseMessengerApp/MessengerReplayForm";
import ConversationThreadAssignableTaskCreateAction
	from "@/actions/Conversation/ConversationThreadAssignableTaskCreateAction";
import {ChannelDataRequiredInterface} from "@/actions/interface/ChannelInterface";
import MessengerService from "@/lib/messenger/MessengerService";

export default class ConversationThreadCreateAction extends BaseAction {
	private workspaceId: number;
	private channelId: number;
	private conversationId: string;
	private message: ConversationMessageCreateInputInterface;
	private conversation: ConversationDocOutputInterface;
	private thread: ConversationThreadOutputInterface | any;
	private threadMessages: {
		startMessage: ConversationMessageDocOutputInterface | null,
		consumerMessage: ConversationMessageDocOutputInterface | null,
		channelAutoReplyMessage: ConversationMessageDocOutputInterface | null
	};
	private assignableTask: AssignableTaskDocOutputInterface;
	private conversationQuery: ConversationQuery;
	private channelQuery: ChannelQuery;
	private channel: any;
	private channelUser: ConversationParticipantUserInterface;
	private consumerUser: ConversationParticipantUserInterface;
	private threadQuery: ThreadQuery
	private messageQuery: MessageQuery;
	private userId: number;
	private currentThreadId: number;
	private messageSourceMid: string;

	constructor(
		workspaceId: number,
		channelId: number,
		conversationId: string,
		message: ConversationMessageCreateInputInterface
	) {
		super()

		this.workspaceId = workspaceId
		this.channelId = channelId
		this.conversationId = conversationId
		this.message = message
		this.messageSourceMid = message?.sourceMid

		// Query Class
		this.conversationQuery = new ConversationQuery
		this.channelQuery = new ChannelQuery
		this.threadQuery = new ThreadQuery
		this.messageQuery = new MessageQuery
	}

	async execute() {
		try {

			this.conversation = await this.conversationQuery.findConversationById(this.conversationId)

			throwIf(
				this.conversation.currentThreadId > 0,
				new Error("Please close your current thread to create a new one.")
			)


			this.channel = await this.channelQuery.findChannelById(this.channelId)
			this.userId = this.channel.workspace.userId

			this.channelUser = {
				id: this.channel.channelData.accountId,
				name: this.channel.channelName,
				role: 'agent'
			}

			const consumerUser = collect(this.conversation.participants).firstWhere('role', 'consumer')
			this.consumerUser = {
				id: consumerUser.id,
				name: consumerUser.name,
				role: consumerUser.role
			}

			// Create New Conversation Thread
			this.thread = await this.createNewThread()
			this.currentThreadId = this.thread.id
			throwIf(!this.currentThreadId, new Error('Invalid currentThreadId'))

			this.conversation.currentThreadId = this.currentThreadId

			// Insert Thread Start Message
			const startMessage = await this.insertThreadStartMessage()
			const consumerMessage = await this.insertThreadConsumerMessage()
			const channelAutoReplyMessage = await this.insertThreadChannelAutoReplyMessage()

			this.threadMessages = {
				startMessage,
				consumerMessage,
				channelAutoReplyMessage
			}

			this.thread = await this.threadQuery.updateThreadByQuery({ id: this.currentThreadId }, { messageId: consumerMessage._id })
			this.assignableTask = await this.createNewAssignableTask(this.thread)

			throwIf(!this.threadMessages.channelAutoReplyMessage?._id, new Error("Invalid Channel Auto Reply Message."))

			const channelAutoReplyMessageContent = this.threadMessages.channelAutoReplyMessage.content.toString()

			// Send Channel Auto Replay Message to the consumer
			await this.sendAutoReplayMessageToConsumer(
				this.channel.channelData,
				this.consumerUser.id,
				channelAutoReplyMessageContent
			)

			// Update the conversation
			const conversationLastMessage: ConversationLastMessageInterface = {
				id: channelAutoReplyMessage._id,
				messageType: channelAutoReplyMessage.messageType,
				content: channelAutoReplyMessageContent,
				createdTime: channelAutoReplyMessage.createdTime
			}

			const updatedConversationData = {
				currentThreadId: this.currentThreadId,
				lastMessage: conversationLastMessage,
				canReplay: true,
				conversationClosed: false
			}

			debugLog(`updatedConversationData: `, updatedConversationData)

			const updatedConversation = await this.conversationQuery.updateAndGetConversationDoc(
				this.conversationId,
				updatedConversationData
			)

			this.conversation = updatedConversation


			throwIf(
				!this.conversation?._id ||
				! this.conversation?.currentThreadId ||
				! this.thread?.id ||
				! this.assignableTask?._id ||
				! this.threadMessages.consumerMessage?._id ||
				! this.threadMessages.channelAutoReplyMessage?._id,
				new Error('Invalid Thread Create Process Detected')
			)

			return Promise.resolve({
				conversation: this.conversation,
				conversationThread: this.thread,
				conversationThreadAssignableTask: this.assignableTask,
				threadMessages: this.threadMessages,
			})

		}catch (e) {
			debugLog(`ConversationThreadCreateActionNew Error: `, e)
			return Promise.reject(e)
		}
	}

	private async createNewThread() {
		try {
			const newThreadData: ThreadCreateInputInterface = {
				workspaceId: this.workspaceId,
				channelId: this.channelId,
				conversationId: this.conversationId,
				messageId: this.messageSourceMid,
				title: this.message.content.toString(),
				content: this.message.content.toString(),
				author: this.message.from
			}

			const promiseData: ConversationThreadOutputInterface = await this.threadQuery.createNewThread(newThreadData)
			return Promise.resolve(promiseData)
		}catch (e) {
			debugLog('createNewThread Error: ', e.message)
			return Promise.reject("Failed to create new Thread")
		}
	}

	async insertThreadStartMessage() {
		try {
			const sourceMid = getAutoGeneratedSourceMid('THREAD_CONVERSATION_START__')

			const consumerMessageData: ConversationMessageCreateInputInterface = {
				...this.message,
				messageType: 'conversation_start',
				content: '/start',
				sourceMid: sourceMid,
				from: this.consumerUser,
				threadId: this.currentThreadId
			}

			const messageCreateActionResponse = await (new ConversationMessageCreateAction(
				this.workspaceId,
				this.channelId,
				this.userId,
				this.conversationId,
				this.currentThreadId,
				this.messageSourceMid,
				this.channel,
				consumerMessageData,
			)).execute()

			this.conversation = messageCreateActionResponse.conversation


			return Promise.resolve(messageCreateActionResponse.conversationMessage)
		}catch (e) {
			debugLog(`insertThreadStartMessage Error: `, e.message)
			return Promise.reject(e)
		}
	}

	private async insertThreadConsumerMessage() {
		try {
			const consumerMessageData = {
				...this.message,
				from: this.consumerUser,
				isAgentReplied: false,
				iceFeedback: false,
				threadId: this.currentThreadId
			}

			const messageCreateActionResponse = await (new ConversationMessageCreateAction(
				this.workspaceId,
				this.channelId,
				this.userId,
				this.conversationId,
				this.currentThreadId,
				this.messageSourceMid,
				this.channel,
				consumerMessageData
			)).execute()

			this.conversation = messageCreateActionResponse.conversation

			return Promise.resolve(messageCreateActionResponse.conversationMessage)
		}catch (e) {
			return Promise.reject("Failed to create conversation consumer message")
		}
	}

	private async insertThreadChannelAutoReplyMessage() {
		try {
			const autoReplyContent = getChannelAutoReplayContent()
			const sourceMid = getAutoGeneratedSourceMid('CHANNEL_AUTO_REPLAY__')

			const channelAutoReplyMessageData: ConversationMessageCreateInputInterface = {
				...this.message,
				messageType: 'channel_auto_replay',
				content: autoReplyContent,
				from: this.channelUser,
				to: this.consumerUser,
				threadId: this.currentThreadId,
				sourceMid: sourceMid,
				conversationId: this.conversationId,
				isAgentReplied: true,
				iceFeedback: false
			}

			const messageCreateActionResponse = await (new ConversationMessageCreateAction(
				this.workspaceId,
				this.channelId,
				this.userId,
				this.conversationId,
				this.currentThreadId,
				sourceMid,
				this.channel,
				channelAutoReplyMessageData
			)).execute()

			throwIf(!messageCreateActionResponse.conversationMessage._id, new Error('Invalid conversationMessage'))

			this.conversation = messageCreateActionResponse.conversation

			return Promise.resolve(messageCreateActionResponse.conversationMessage)

		}catch (e) {
			debugLog(`auto reply message create error: `, e)
			return Promise.reject("Failed to create conversation channel auto reply message")
		}
	}

	private async createNewAssignableTask(thread: ConversationThreadOutputInterface) {
		try {
			// TODO: Create Assignable Task for the Thread
			const assignableTaskCreateData = {
				conversationId: thread.conversationId,
				threadId: thread.id,
				messageDocId: thread.messageId,
				threadTitle: thread?.content
			}

			const actionResponse = await (new ConversationThreadAssignableTaskCreateAction(
				{
					workspaceId: this.workspaceId,
					channelId: this.channelId,
					userId: this.userId
				},
				assignableTaskCreateData
			)).execute()

			const assignableTaskDoc: AssignableTaskDocOutputInterface = actionResponse?.data?.assignableTask
			const assignableTaskDocId = assignableTaskDoc?._id
			throwIf(!assignableTaskDocId, new Error("Assignable Task Doc is invalid"))

			return Promise.resolve(assignableTaskDoc)

		}catch (e) {
			return Promise.reject("Failed to create new Assignable Task")
		}
	}

	async sendAutoReplayMessageToConsumer(
		channelData: ChannelDataRequiredInterface,
		recipientId: string,
		messageText: string
	) {
		try {

			const pageId = channelData.accountId
			const pageAccessToken = channelData.accessToken

			const messengerService = new MessengerService(pageId, pageAccessToken)
			const messageSentResponse = await messengerService.sendMessage(recipientId, messageText)
			debugLog(`Channel Auto Reply Message Sent Response `, messageSentResponse)

			return Promise.resolve(messageSentResponse)
		}catch (e) {
			return Promise.reject('Failed to send channel auto reply message to consumer')
		}
	}
}