import BaseAction from "@/actions/BaseAction";
import {debugLog, generateChannelUid, getAutoGeneratedSourceMid, getCurrentTimestamp} from "@/utils/helperFunctions";
import ChannelQuery from "@/lib/QueryServices/backend/ChannelQuery";
import {ChannelDataRequiredInterface} from "@/actions/interface/ChannelInterface";
import {throwIf} from "@/lib/ErrorHandler";
import ConversationQuery from "@/lib/QueryServices/elasticsearch/ConversationQuery";
import TaskQuery from "@/lib/QueryServices/elasticsearch/TaskQuery";
import {
    ConversationDocOutputInterface,
    ConversationMessageCreateInputInterface, ConversationMessageDocOutputInterface, ConversationParticipantUserInterface
} from "@/actions/interface/ConversationInterface";
import {AgentAssignedTaskDocReadInterface} from "@/actions/interface/AgentInterface";
import ConversationMessageCreateAction from "@/actions/Conversation/ConversationMessageCreateAction";
import {ConversationCreateActionParamsInterface} from "@/actions/interface/ConversationActionClassInterface";
import collect from "collect.js";
import ThreadQuery from "@/lib/QueryServices/backend/ThreadQuery";
import ConverseMessengerSocketEmitter from "@/lib/ConverseMessengerService/ConverseMessengerSocketEmitter";

interface DisconnectAgentFromConsumerActionParams {
    channelType: string;
    accountId: string;
    consumerId: string;
}

export default class DisconnectAgentFromConsumerAction extends BaseAction{
    private channelType: string;
    private accountId: string;
    private consumerId: string;
    private channelUid: string;
    private channel: any;
    private channelData: ChannelDataRequiredInterface;
    private channelId: number;
    private consumerConversation: ConversationDocOutputInterface;
    private consumerAssignedAgentTask: AgentAssignedTaskDocReadInterface;
    private currentThreadId: number;
    private workspaceId: number;
    private userId: number;
    private consumerUser: ConversationParticipantUserInterface;
    private agentUser: ConversationParticipantUserInterface;
    private consumerForceClosedMessage: ConversationMessageDocOutputInterface;
    private consumerForceClosedThread: any;
    private consumerForceClosedThreadTask: AgentAssignedTaskDocReadInterface;
    private consumerForceClosedConversation: ConversationDocOutputInterface;

    constructor(params: DisconnectAgentFromConsumerActionParams) {
        super()

        this.channelType = params.channelType
        this.accountId = params.accountId
        this.consumerId = params.consumerId
        
        this.channelUid = generateChannelUid(this.channelType, this.accountId)
    }

    async execute() {

        try {

            const channel = await (new ChannelQuery()).findUniqueChannelByChannelUid(
                this.channelType,
                this.channelUid
            )
            const channelId = channel?.id
            const channelData: ChannelDataRequiredInterface = channel?.channelData
            const channelAccountId = channelData?.accountId
            const channelAccessToken = channelData?.accessToken
            const channelAuthorized = channelData?.authorized

            throwIf(
                !channelId ||
                !channelAccountId ||
                !channelAccessToken,
                new Error('Sorry your request is invalid.')
            )

            throwIf(
                !channelAuthorized,
                new Error('Unauthorized Channel.')
            )

            // Set the Important data
            this.channel = channel
            this.channelId = channel.id
            this.channelData = channelData

            // Find the channel conversations
            const consumerConversation = await (new ConversationQuery())
                .findConversationByConsumerId(channelId, this.consumerId)

            const currentThreadId = consumerConversation?.currentThreadId

            throwIf(!consumerConversation?._id, new Error('Invalid Consumer Conversation'))
            throwIf(!currentThreadId, new Error('Consumer currentThreadId not found.'))

            const participantsCollection = collect(consumerConversation.participants)

            this.currentThreadId = currentThreadId
            this.workspaceId = consumerConversation.workspaceId
            this.userId = this.channel.workspace.userId
            this.consumerUser = participantsCollection.firstWhere('role', 'consumer')
            this.agentUser = participantsCollection.firstWhere('id', this.accountId)
            this.consumerConversation = consumerConversation

            // Find the currentThreadTask
            const currentThreadTask = await (new TaskQuery())
                .findConsumerAssignedAgentTaskByThreadId(currentThreadId)

            this.setConsumerConversation(consumerConversation)
            this.setConsumerAgentAssignedTask(currentThreadTask)

            if(currentThreadTask && currentThreadTask?.assignedAgentId){
                const assignedAgentId = currentThreadTask?.assignedAgentId
                throwIf(!assignedAgentId, new Error('Sorry! currently no agent is available for the consumer.'))
                throwIf(currentThreadTask?.sourceData?.channelId !== channelId, new Error("Invalid ChannelId while disconnecting agent from the consumer"))

                // Dispatch Socket Emit
                this.dispatchSocketEvents()
            }

            const consumerDisconnectResponse = await this.forceCloseTheConsumerTaskAndDisconnectFromTheAgent()

            return Promise.resolve(consumerDisconnectResponse)

        }catch (e) {
            debugLog('ERROR IN : DisconnectAgentFromConsumerAction', e.message)
            debugLog('ERROR IN : DisconnectAgentFromConsumerAction', e)
            return Promise.reject(e)
        }

    }

    private setConsumerConversation(consumerConversation: ConversationDocOutputInterface) {
        this.consumerConversation = consumerConversation
    }

    private setConsumerAgentAssignedTask(consumerAssignedAgentTask: AgentAssignedTaskDocReadInterface) {
        this.consumerAssignedAgentTask = consumerAssignedAgentTask
    }

    private async forceCloseTheConsumerTaskAndDisconnectFromTheAgent() {
        try {

            // TODO: 1. Update The Task with consumerForceClosed true
            const consumerForceClosedThreadTask: AgentAssignedTaskDocReadInterface = await (new TaskQuery())
                .closeTheTaskByThreadId(
                    this.currentThreadId,
                    false,
                    false,
                    true,
                )

            // TODO: 2. Create a new Closing Message about Consumer Force Closed and Disconnection
            const messageInsertResponse = await this.insertNewMessage()
            const {conversationMessage: consumerForceClosedMessage} = messageInsertResponse
            throwIf(!consumerForceClosedMessage?._id, new Error("Consumer Force Closed Message is Invalid"))

            // TODO: 3. Close the Thread
            const consumerForceClosedThread: any = await (new ThreadQuery())
                .updateThreadByQuery(
                    { id: this.currentThreadId },
                    { isClosed: true }
                )

            // TODO: 4. Updated the Conversation
            const consumerForceClosedConversation = await (new ConversationQuery())
                .updateAndGetConversationDoc(
                    this.consumerConversation._id,
                    {
                        currentThreadId: null,
                        canReply: false,
                        conversationClosed: true
                    }
                )

            this.setConsumerForceClosedConversation(consumerForceClosedConversation)
            this.setConsumerForceClosedMessage(consumerForceClosedMessage)
            this.setConsumerForceClosedThread(consumerForceClosedThread)
            this.setConsumerForceClosedThreadTask(consumerForceClosedThreadTask)

            return Promise.resolve({
                consumerForceClosedConversation,
                consumerForceClosedMessage,
                consumerForceClosedThread,
                consumerForceClosedThreadTask,
            })
        }catch (e) {
            debugLog('ERROR IN: forceCloseTheConsumerTaskAndDisconnectFromTheAgent', e.message)
            return Promise.reject(e)
        }
    }

    private async insertNewMessage() {
        try {
            const params: ConversationCreateActionParamsInterface = {
                workspaceId: this.workspaceId,
                channelId: this.channelId,
                userId: this.userId,
            }

            const sourceMid = getAutoGeneratedSourceMid('CONSUMER_THREAD_FORCE_CLOSED__')
            const conversationId = this.consumerConversation._id

            const message: ConversationMessageCreateInputInterface = {
                messageType: 'consumer_force_closed',
                content: 'Consumer Force Closed the thread conversation with the Agent',
                from: this.consumerUser,
                to: this.agentUser,
                threadId: this.currentThreadId,
                createdTime: getCurrentTimestamp(),
                channelAccountId: this.accountId,
                sourceMid: sourceMid,
                conversationId: conversationId,
                closed: true,
                consumerForceClosed: true
            }

            const messageCreateAction = new ConversationMessageCreateAction(
                this.workspaceId,
                this.channelId,
                this.userId,
                conversationId,
                this.currentThreadId,
                sourceMid,
                this.channel,
                message,
            )

            const messageCreateActionResponse = await messageCreateAction.execute()
            this.consumerConversation = messageCreateActionResponse.conversation

            return Promise.resolve({
                conversation: messageCreateActionResponse.conversation,
                conversationMessage: messageCreateActionResponse.conversationMessage
            })
        }catch (e) {
            return Promise.reject(e)
        }
    }

    private setConsumerForceClosedMessage(consumerForceCloseMessage: ConversationMessageDocOutputInterface) {
        this.consumerForceClosedMessage = consumerForceCloseMessage
    }

    private setConsumerForceClosedThread(consumerForceClosedThread: any) {
        this.consumerForceClosedThread = consumerForceClosedThread
    }

    private setConsumerForceClosedThreadTask(consumerForceClosedThreadTask: AgentAssignedTaskDocReadInterface) {
        this.consumerForceClosedThreadTask = consumerForceClosedThreadTask
    }

    private setConsumerForceClosedConversation(consumerForceClosedConversation: ConversationDocOutputInterface) {
        this.consumerForceClosedConversation = consumerForceClosedConversation
    }

    private dispatchSocketEvents() {
        try {

            const socketEmitter = new ConverseMessengerSocketEmitter(
                this.workspaceId,
                this.channelId
            )

            socketEmitter.agentTaskClosed(this.consumerForceClosedThreadTask)

        }catch (e) {
            return Promise.reject(e)
        }
    }
}