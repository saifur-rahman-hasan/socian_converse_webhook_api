import moment from "moment";
import {SHA256} from "crypto-js";
import {throwIf} from "@/lib/ErrorHandler";
import {ConversationMessageDocOutputInterface, ThreadMessage} from "@/actions/interface/ConversationInterface";

export function slugify(text: string, separator: string = '-'): string {
	// Replace any non-word character with the separator
	const slug: string = text.toLowerCase().replace(/[\W_]+/g, separator);

	// Trim any leading or trailing separators
	return slug.replace(new RegExp(`^${separator}+|${separator}+$`, 'g'), '');
}

/**
 * Generate ConversationUid
 * Format: {workspaceId}_{channelType}_{channelId}_{consumerId}
 *
 * @param workspaceId
 * @param channelType
 * @param channelId
 * @param consumerId
 */
export function generateConsumerConversationUid(
	workspaceId: number,
	channelType: string,
	channelId: number,
	consumerId: string
): string {
	return `${workspaceId}_${channelType}_${channelId}_${consumerId}`;
}

/**
 * Generate ChannelUid
 *
 * @param channelType
 * @param channelAccountId
 */
export function generateChannelUid(
	channelType: string,
	channelAccountId: string,
): string {
	return `${channelType}_${channelAccountId}`;
}

export function formatSeconds(seconds:number) {
	const minutes:number = Math.floor(seconds / 60);
	const remainingSeconds:number = seconds % 60;
	const formattedTime:string = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
	return formattedTime;
}

export const now = () => new Date()

export function calculateDurationInSeconds(taskStartTimestamp: string, taskEndTimestamp: string) {
	const start = new Date(taskStartTimestamp);
	const end = new Date(taskEndTimestamp);
	const durationInMilliseconds = end.getTime() - start.getTime();
	return Math.floor(durationInMilliseconds / 1000);
}

export function generateTimestamp(timestamp = null) {
	if (timestamp !== null) {
		// If a timestamp is provided, convert it to the desired format
		const parsedTimestamp = Date.parse(timestamp);
		if (!isNaN(parsedTimestamp)) {
			const additionalDigits = Math.floor(Math.random() * 100); // Generates a random 2-digit number (00 to 99)
			return `${parsedTimestamp / 1000}${additionalDigits.toString().padStart(2, '0')}`;
		} else {
			throw new Error('Invalid timestamp format. Please provide a valid date string or timestamp.');
		}
	} else {
		// If no timestamp provided, generate the timestamp based on the current time
		const currentTimestamp = Date.now();
		const additionalDigits = Math.floor(Math.random() * 100); // Generates a random 2-digit number (00 to 99)
		return `${currentTimestamp / 1000}${additionalDigits.toString().padStart(2, '0')}`;
	}
}

export function formatTimestampToAgo(timestamp: string): string {
	// Parse the timestamp into a valid moment object
	const date = moment(parseInt(timestamp));

	// Calculate the difference between the current time and the given timestamp
	const diffInMilliseconds = moment().diff(date);

	// Use moment's "fromNow" method to get the relative time in the "ago" format
	return moment.duration(diffInMilliseconds).humanize() + ' ago';
}

export function getCurrentTimestamp(): string {
	return Date.now().toString();
}

export function debugLog(title: string, data: any): void {
	console.log(`debugLog: ${title}`);
	console.log(JSON.stringify(data, null, 2));
	console.log(`exit debugLog: ${title}`);
}

export function generateSHA256Hash() {
	const randomString = generateRandomString(10); // Generate a random string of length 10
	return SHA256(randomString).toString();
}

export function generateRandomString(length) {
	const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	let result = '';
	for (let i = 0; i < length; i++) {
		const randomIndex = Math.floor(Math.random() * characters.length);
		result += characters.charAt(randomIndex);
	}
	return result;
}

export function thirdPartyChannelWebhookRequestVerification(
	authorizationBearerToken: string,
	VERIFY_TOKEN: string
) {
	throwIf(!authorizationBearerToken, new Error('Unauthorized Access'))
	const webhookAccessToken = authorizationBearerToken.split('Bearer ')[1].trim()
	throwIf(!webhookAccessToken, new Error('The webhook_access_token is required.'))
	throwIf(
		webhookAccessToken !== VERIFY_TOKEN,
		new Error('Invalid Webhook Access Token.')
	)

	return true
}

export function getAutoGeneratedSourceMid(prefix = '') {
	const timestamp = Date.now().toString();
	const randomId = Math.floor(Math.random() * 1000); // Add a random ID to ensure uniqueness

	return `${prefix}${timestamp}_${randomId}`;
}

export function getAuthId(req: any) {
	return req?.authUser?.user_id || req?.authUser?.authUserId || undefined
}

export function calculateTaskDurationInSeconds(taskStartTimestamp: string): number {
	const startTimestamp = new Date(taskStartTimestamp);
	const endTimestamp = new Date(); // Current time

	const durationInMilliseconds = endTimestamp.getTime() - startTimestamp.getTime();
	return durationInMilliseconds / 1000;
}

export function isCloseableIceResponse(messageText: string): boolean {
	// const validStrings: string[] = ["Y", "y", "Yes", "yes", "N", "n", "No", "no", "good", "bad", "হ্যাঁ", "না", "ভাল", "খারাপ"];

	const validStrings: string[] = ["Y", "N", "y", "n"];
	return validStrings.includes(messageText);
}

export function getChannelAutoReplayContent() {
	return "Thank you for connecting with Customer Service Agent. How may I help you?";
}

export function filterConsumerMessagesAfterIceFeedbackSent(threadMessages: ConversationMessageDocOutputInterface[]): ThreadMessage[] {
	let found = false;

	return threadMessages.reduce((afterAgentIceMessages, message) => {
		if (!found && message.isAgentReplied && message.iceFeedback && message.messageType === 'iceFeedback') {
			found = true;
			return [...afterAgentIceMessages, message];
		}

		if (found) {
			const allowedMessageTypes = [
				'quick_reply',
				'text',
				'attachment_image',
				'attachment_audio',
				'attachment_video',
			];

			if (allowedMessageTypes.includes(message.messageType)) {
				message.closed = message.messageType === 'quick_reply';
				return [...afterAgentIceMessages, message];
			}

			if (message.messageType === 'echo') {
				return [...afterAgentIceMessages, message];
			}

			return afterAgentIceMessages;
		}

		return afterAgentIceMessages;
	}, []);
}